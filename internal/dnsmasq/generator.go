// Copyright (c) Elio Severo Junior
// SPDX-License-Identifier: MIT

package dnsmasq

import (
	"bytes"
	"fmt"
	"strings"
)

// Generator converts Config to dnsmasq.conf format.
type Generator struct {
	config *Config
	opts   GeneratorOptions
}

// GeneratorOptions configures the generator behavior.
type GeneratorOptions struct {
	// Include comments in output
	IncludeComments bool

	// Sort options alphabetically within sections
	SortOptions bool
}

// NewGenerator creates a new configuration generator.
func NewGenerator(config *Config, opts GeneratorOptions) *Generator {
	return &Generator{
		config: config,
		opts:   opts,
	}
}

// Generate produces the dnsmasq.conf content.
func (g *Generator) Generate() ([]byte, error) {
	var buf bytes.Buffer

	if g.opts.IncludeComments {
		buf.WriteString("# Terraform-managed dnsmasq configuration\n")
		buf.WriteString("# Generated by terraform-provider-dnsmasq\n")
		buf.WriteString("# DO NOT EDIT MANUALLY\n\n")
	}

	if err := g.generateGlobal(&buf); err != nil {
		return nil, fmt.Errorf("failed to generate global config: %w", err)
	}

	if err := g.generateDNS(&buf); err != nil {
		return nil, fmt.Errorf("failed to generate DNS config: %w", err)
	}

	if err := g.generateDNSSEC(&buf); err != nil {
		return nil, fmt.Errorf("failed to generate DNSSEC config: %w", err)
	}

	if err := g.generateRecords(&buf); err != nil {
		return nil, fmt.Errorf("failed to generate records: %w", err)
	}

	if err := g.generateDHCP(&buf); err != nil {
		return nil, fmt.Errorf("failed to generate DHCP config: %w", err)
	}

	if err := g.generateDHCPHosts(&buf); err != nil {
		return nil, fmt.Errorf("failed to generate DHCP hosts: %w", err)
	}

	if err := g.generateTFTP(&buf); err != nil {
		return nil, fmt.Errorf("failed to generate TFTP config: %w", err)
	}

	if err := g.generatePXE(&buf); err != nil {
		return nil, fmt.Errorf("failed to generate PXE config: %w", err)
	}

	if err := g.generateRA(&buf); err != nil {
		return nil, fmt.Errorf("failed to generate RA config: %w", err)
	}

	if err := g.generateCustom(&buf); err != nil {
		return nil, fmt.Errorf("failed to generate custom options: %w", err)
	}

	return buf.Bytes(), nil
}

func (g *Generator) generateGlobal(buf *bytes.Buffer) error {
	if g.config.Global == nil {
		return nil
	}

	cfg := g.config.Global

	if g.opts.IncludeComments {
		buf.WriteString("# Global settings\n")
	}

	if cfg.User != "" {
		fmt.Fprintf(buf, "user=%s\n", cfg.User)
	}
	if cfg.Group != "" {
		fmt.Fprintf(buf, "group=%s\n", cfg.Group)
	}
	if cfg.LogQueries {
		buf.WriteString("log-queries\n")
	}
	if cfg.LogFacility != "" {
		fmt.Fprintf(buf, "log-facility=%s\n", cfg.LogFacility)
	}
	if cfg.LogDHCP {
		buf.WriteString("log-dhcp\n")
	}
	if cfg.LogAsync > 0 {
		fmt.Fprintf(buf, "log-async=%d\n", cfg.LogAsync)
	}
	if cfg.ConfDir != "" {
		fmt.Fprintf(buf, "conf-dir=%s\n", cfg.ConfDir)
	}
	for _, f := range cfg.ConfFile {
		fmt.Fprintf(buf, "conf-file=%s\n", f)
	}
	if cfg.NoHosts {
		buf.WriteString("no-hosts\n")
	}
	for _, h := range cfg.AddnHosts {
		fmt.Fprintf(buf, "addn-hosts=%s\n", h)
	}
	if cfg.ExpandHosts {
		buf.WriteString("expand-hosts\n")
	}
	if cfg.Domain != "" {
		fmt.Fprintf(buf, "domain=%s\n", cfg.Domain)
	}
	if cfg.Local != "" {
		fmt.Fprintf(buf, "local=%s\n", cfg.Local)
	}
	if cfg.FilterWin2K {
		buf.WriteString("filterwin2k\n")
	}
	if cfg.LocaliseQueries {
		buf.WriteString("localise-queries\n")
	}
	if cfg.PidFile != "" {
		fmt.Fprintf(buf, "pid-file=%s\n", cfg.PidFile)
	}
	if cfg.NoResolv {
		buf.WriteString("no-resolv\n")
	}
	if cfg.ResolvFile != "" {
		fmt.Fprintf(buf, "resolv-file=%s\n", cfg.ResolvFile)
	}
	if cfg.NoPoll {
		buf.WriteString("no-poll\n")
	}

	buf.WriteString("\n")
	return nil
}

func (g *Generator) generateDNS(buf *bytes.Buffer) error {
	if g.config.DNS == nil {
		return nil
	}

	cfg := g.config.DNS

	if g.opts.IncludeComments {
		buf.WriteString("# DNS settings\n")
	}

	if cfg.Port > 0 {
		fmt.Fprintf(buf, "port=%d\n", cfg.Port)
	}
	for _, addr := range cfg.ListenAddress {
		fmt.Fprintf(buf, "listen-address=%s\n", addr)
	}
	for _, iface := range cfg.Interface {
		fmt.Fprintf(buf, "interface=%s\n", iface)
	}
	for _, iface := range cfg.ExceptInterface {
		fmt.Fprintf(buf, "except-interface=%s\n", iface)
	}
	if cfg.BindInterfaces {
		buf.WriteString("bind-interfaces\n")
	}
	if cfg.BindDynamic {
		buf.WriteString("bind-dynamic\n")
	}

	// Upstream servers
	for _, srv := range cfg.Servers {
		if srv.Domain != "" {
			fmt.Fprintf(buf, "server=/%s/%s\n", srv.Domain, srv.Address)
		} else {
			fmt.Fprintf(buf, "server=%s\n", srv.Address)
		}
	}

	// Reverse DNS servers
	for _, rsrv := range cfg.RevServers {
		fmt.Fprintf(buf, "rev-server=%s,%s\n", rsrv.Subnet, rsrv.Nameserver)
	}

	// Query behavior
	if cfg.StrictOrder {
		buf.WriteString("strict-order\n")
	}
	if cfg.AllServers {
		buf.WriteString("all-servers\n")
	}
	if cfg.DomainNeeded {
		buf.WriteString("domain-needed\n")
	}
	if cfg.BogusPriv {
		buf.WriteString("bogus-priv\n")
	}
	if cfg.DNSLoopDetect {
		buf.WriteString("dns-loop-detect\n")
	}
	if cfg.StopDNSRebind {
		buf.WriteString("stop-dns-rebind\n")
	}
	if cfg.RebindLocalhostOK {
		buf.WriteString("rebind-localhost-ok\n")
	}
	for _, domain := range cfg.RebindDomainOK {
		fmt.Fprintf(buf, "rebind-domain-ok=%s\n", domain)
	}

	if cfg.ServersFile != "" {
		fmt.Fprintf(buf, "servers-file=%s\n", cfg.ServersFile)
	}

	// Cache settings
	if cfg.CacheSize > 0 {
		fmt.Fprintf(buf, "cache-size=%d\n", cfg.CacheSize)
	}
	if cfg.NoNegcache {
		buf.WriteString("no-negcache\n")
	}
	if cfg.LocalTTL > 0 {
		fmt.Fprintf(buf, "local-ttl=%d\n", cfg.LocalTTL)
	}
	if cfg.NegTTL > 0 {
		fmt.Fprintf(buf, "neg-ttl=%d\n", cfg.NegTTL)
	}
	if cfg.MaxTTL > 0 {
		fmt.Fprintf(buf, "max-ttl=%d\n", cfg.MaxTTL)
	}
	if cfg.MaxCacheTTL > 0 {
		fmt.Fprintf(buf, "max-cache-ttl=%d\n", cfg.MaxCacheTTL)
	}
	if cfg.MinCacheTTL > 0 {
		fmt.Fprintf(buf, "min-cache-ttl=%d\n", cfg.MinCacheTTL)
	}
	if cfg.AuthTTL > 0 {
		fmt.Fprintf(buf, "auth-ttl=%d\n", cfg.AuthTTL)
	}
	if cfg.EDNSPacketMax > 0 {
		fmt.Fprintf(buf, "edns-packet-max=%d\n", cfg.EDNSPacketMax)
	}
	if cfg.DNSForwardMax > 0 {
		fmt.Fprintf(buf, "dns-forward-max=%d\n", cfg.DNSForwardMax)
	}

	buf.WriteString("\n")
	return nil
}

func (g *Generator) generateDNSSEC(buf *bytes.Buffer) error {
	if g.config.DNSSEC == nil || !g.config.DNSSEC.Enabled {
		return nil
	}

	cfg := g.config.DNSSEC

	if g.opts.IncludeComments {
		buf.WriteString("# DNSSEC settings\n")
	}

	buf.WriteString("dnssec\n")
	if cfg.CheckUnsigned {
		buf.WriteString("dnssec-check-unsigned\n")
	}
	if cfg.NoTimecheck {
		buf.WriteString("dnssec-no-timecheck\n")
	}
	for _, ta := range cfg.TrustAnchor {
		fmt.Fprintf(buf, "trust-anchor=%s\n", ta)
	}
	if cfg.Timestamp != "" {
		fmt.Fprintf(buf, "dnssec-timestamp=%s\n", cfg.Timestamp)
	}

	buf.WriteString("\n")
	return nil
}

func (g *Generator) generateRecords(buf *bytes.Buffer) error {
	hasRecords := len(g.config.HostRecords) > 0 ||
		len(g.config.AddressRecords) > 0 ||
		len(g.config.CNAMERecords) > 0 ||
		len(g.config.MXRecords) > 0 ||
		len(g.config.SRVRecords) > 0 ||
		len(g.config.TXTRecords) > 0 ||
		len(g.config.PTRRecords) > 0 ||
		len(g.config.NAPTRRecords) > 0 ||
		len(g.config.CAARecords) > 0

	if !hasRecords {
		return nil
	}

	if g.opts.IncludeComments {
		buf.WriteString("# DNS Records\n")
	}

	// Host records (A/AAAA/PTR)
	for _, hr := range g.config.HostRecords {
		parts := []string{hr.Name}
		if hr.IPv4 != "" {
			parts = append(parts, hr.IPv4)
		}
		if hr.IPv6 != "" {
			parts = append(parts, hr.IPv6)
		}
		if hr.TTL > 0 {
			parts = append(parts, fmt.Sprintf("%d", hr.TTL))
		}
		fmt.Fprintf(buf, "host-record=%s\n", strings.Join(parts, ","))
	}

	// Address records
	for _, ar := range g.config.AddressRecords {
		fmt.Fprintf(buf, "address=/%s/%s\n", ar.Domain, ar.IP)
	}

	// CNAME records
	for _, cr := range g.config.CNAMERecords {
		fmt.Fprintf(buf, "cname=%s,%s\n", cr.Alias, cr.Target)
	}

	// MX records
	for _, mx := range g.config.MXRecords {
		fmt.Fprintf(buf, "mx-host=%s,%s,%d\n", mx.Domain, mx.Target, mx.Preference)
	}

	// SRV records
	for _, srv := range g.config.SRVRecords {
		fmt.Fprintf(buf, "srv-host=%s,%s,%d,%d,%d\n",
			srv.Service, srv.Target, srv.Port, srv.Priority, srv.Weight)
	}

	// TXT records
	for _, txt := range g.config.TXTRecords {
		fmt.Fprintf(buf, "txt-record=%s,\"%s\"\n", txt.Name, escapeQuotes(txt.Value))
	}

	// PTR records
	for _, ptr := range g.config.PTRRecords {
		fmt.Fprintf(buf, "ptr-record=%s,%s\n", ptr.PTRName, ptr.Target)
	}

	// NAPTR records
	for _, naptr := range g.config.NAPTRRecords {
		fmt.Fprintf(buf, "naptr-record=%s,%d,%d,\"%s\",\"%s\",\"%s\",%s\n",
			naptr.Name, naptr.Order, naptr.Preference,
			naptr.Flags, naptr.Service, naptr.Regexp, naptr.Replacement)
	}

	// CAA records
	for _, caa := range g.config.CAARecords {
		fmt.Fprintf(buf, "caa-record=%s,%d,%s,\"%s\"\n",
			caa.Name, caa.Flags, caa.Tag, escapeQuotes(caa.Value))
	}

	buf.WriteString("\n")
	return nil
}

func (g *Generator) generateDHCP(buf *bytes.Buffer) error {
	if g.config.DHCP == nil || !g.config.DHCP.Enabled {
		return nil
	}

	cfg := g.config.DHCP

	if g.opts.IncludeComments {
		buf.WriteString("# DHCP settings\n")
	}

	if cfg.Authoritative {
		buf.WriteString("dhcp-authoritative\n")
	}
	if cfg.Leasefile != "" {
		fmt.Fprintf(buf, "dhcp-leasefile=%s\n", cfg.Leasefile)
	}
	if cfg.LeaseMax > 0 {
		fmt.Fprintf(buf, "dhcp-lease-max=%d\n", cfg.LeaseMax)
	}

	// DHCPv4 ranges
	for _, r := range cfg.Ranges {
		parts := []string{}
		if r.Tag != "" {
			parts = append(parts, fmt.Sprintf("set:%s", r.Tag))
		}
		parts = append(parts, r.Start, r.End)
		if r.Netmask != "" {
			parts = append(parts, r.Netmask)
		}
		if r.LeaseTime != "" {
			parts = append(parts, r.LeaseTime)
		}
		fmt.Fprintf(buf, "dhcp-range=%s\n", strings.Join(parts, ","))
	}

	// DHCPv6 ranges
	for _, r := range cfg.RangesV6 {
		parts := []string{}
		if r.Tag != "" {
			parts = append(parts, fmt.Sprintf("tag:%s", r.Tag))
		}
		parts = append(parts, r.Start)
		if r.End != "" {
			parts = append(parts, r.End)
		}
		if r.Constructor != "" {
			parts = append(parts, fmt.Sprintf("constructor:%s", r.Constructor))
		}
		if r.Mode != "" {
			parts = append(parts, r.Mode)
		}
		if r.PrefixLength > 0 {
			parts = append(parts, fmt.Sprintf("%d", r.PrefixLength))
		}
		if r.LeaseTime != "" {
			parts = append(parts, r.LeaseTime)
		}
		fmt.Fprintf(buf, "dhcp-range=%s\n", strings.Join(parts, ","))
	}

	// DHCP options
	for _, opt := range cfg.Options {
		parts := []string{}
		if opt.Tag != "" {
			parts = append(parts, fmt.Sprintf("tag:%s", opt.Tag))
		}
		if opt.Force {
			parts = append(parts, "force")
		}
		if opt.Name != "" {
			parts = append(parts, fmt.Sprintf("option:%s", opt.Name))
		} else if opt.Number > 0 {
			parts = append(parts, fmt.Sprintf("%d", opt.Number))
		}
		parts = append(parts, opt.Value)

		if opt.Force {
			fmt.Fprintf(buf, "dhcp-option-force=%s\n", strings.Join(parts[1:], ","))
		} else {
			fmt.Fprintf(buf, "dhcp-option=%s\n", strings.Join(parts, ","))
		}
	}

	// Vendor classes
	for _, vc := range cfg.VendorClasses {
		fmt.Fprintf(buf, "dhcp-vendorclass=set:%s,%s\n", vc.Tag, vc.Match)
	}

	// User classes
	for _, uc := range cfg.UserClasses {
		fmt.Fprintf(buf, "dhcp-userclass=set:%s,%s\n", uc.Tag, uc.Match)
	}

	// Boot options
	for _, bo := range cfg.BootOptions {
		parts := []string{}
		if bo.Tag != "" {
			parts = append(parts, fmt.Sprintf("tag:%s", bo.Tag))
		}
		parts = append(parts, bo.Filename)
		if bo.Server != "" {
			parts = append(parts, bo.Server)
		}
		fmt.Fprintf(buf, "dhcp-boot=%s\n", strings.Join(parts, ","))
	}

	if cfg.IgnoreNames {
		buf.WriteString("dhcp-ignore-names\n")
	}
	if cfg.GenerateNames {
		buf.WriteString("dhcp-generate-names\n")
	}
	if cfg.Script != "" {
		fmt.Fprintf(buf, "dhcp-script=%s\n", cfg.Script)
	}
	if cfg.ScriptUser != "" {
		fmt.Fprintf(buf, "dhcp-scriptuser=%s\n", cfg.ScriptUser)
	}
	if cfg.RapidCommit {
		buf.WriteString("dhcp-rapid-commit\n")
	}
	if cfg.SequentialIP {
		buf.WriteString("dhcp-sequential-ip\n")
	}
	if cfg.ReadEthers {
		buf.WriteString("read-ethers\n")
	}

	buf.WriteString("\n")
	return nil
}

func (g *Generator) generateDHCPHosts(buf *bytes.Buffer) error {
	if len(g.config.DHCPHosts) == 0 {
		return nil
	}

	if g.opts.IncludeComments {
		buf.WriteString("# DHCP Hosts\n")
	}

	for _, h := range g.config.DHCPHosts {
		parts := []string{}

		if h.MAC != "" {
			parts = append(parts, h.MAC)
		} else if h.ClientID != "" {
			parts = append(parts, fmt.Sprintf("id:%s", h.ClientID))
		}

		if h.Name != "" {
			parts = append(parts, h.Name)
		}
		if h.IP != "" {
			parts = append(parts, h.IP)
		}
		if h.LeaseTime != "" {
			parts = append(parts, h.LeaseTime)
		}
		for _, tag := range h.Tags {
			parts = append(parts, fmt.Sprintf("set:%s", tag))
		}
		if h.Ignore {
			parts = append(parts, "ignore")
		}

		fmt.Fprintf(buf, "dhcp-host=%s\n", strings.Join(parts, ","))
	}

	buf.WriteString("\n")
	return nil
}

func (g *Generator) generateTFTP(buf *bytes.Buffer) error {
	if g.config.TFTP == nil || !g.config.TFTP.Enabled {
		return nil
	}

	cfg := g.config.TFTP

	if g.opts.IncludeComments {
		buf.WriteString("# TFTP settings\n")
	}

	buf.WriteString("enable-tftp\n")
	if cfg.Root != "" {
		fmt.Fprintf(buf, "tftp-root=%s\n", cfg.Root)
	}
	if cfg.Secure {
		buf.WriteString("tftp-secure\n")
	}
	if cfg.NoFail {
		buf.WriteString("tftp-no-fail\n")
	}
	if cfg.UniqueRoot != "" {
		fmt.Fprintf(buf, "tftp-unique-root=%s\n", cfg.UniqueRoot)
	}
	if cfg.Lowercase {
		buf.WriteString("tftp-lowercase\n")
	}
	if cfg.MaxConnections > 0 {
		fmt.Fprintf(buf, "tftp-max=%d\n", cfg.MaxConnections)
	}
	if cfg.MTU > 0 {
		fmt.Fprintf(buf, "tftp-mtu=%d\n", cfg.MTU)
	}
	if cfg.NoBlocksize {
		buf.WriteString("tftp-no-blocksize\n")
	}
	if cfg.PortRange != "" {
		fmt.Fprintf(buf, "tftp-port-range=%s\n", cfg.PortRange)
	}
	if cfg.SinglePort {
		buf.WriteString("tftp-single-port\n")
	}

	buf.WriteString("\n")
	return nil
}

func (g *Generator) generatePXE(buf *bytes.Buffer) error {
	if g.config.PXE == nil {
		return nil
	}

	cfg := g.config.PXE

	if cfg.Prompt == nil && len(cfg.Services) == 0 {
		return nil
	}

	if g.opts.IncludeComments {
		buf.WriteString("# PXE settings\n")
	}

	if cfg.Prompt != nil {
		fmt.Fprintf(buf, "pxe-prompt=\"%s\",%d\n",
			escapeQuotes(cfg.Prompt.Text), cfg.Prompt.Timeout)
	}

	for _, svc := range cfg.Services {
		parts := []string{svc.CSA}
		parts = append(parts, fmt.Sprintf("\"%s\"", escapeQuotes(svc.MenuText)))
		parts = append(parts, svc.Basename)
		if svc.Server != "" {
			parts = append(parts, svc.Server)
		}
		fmt.Fprintf(buf, "pxe-service=%s\n", strings.Join(parts, ","))
	}

	buf.WriteString("\n")
	return nil
}

func (g *Generator) generateRA(buf *bytes.Buffer) error {
	if g.config.RA == nil || !g.config.RA.Enabled {
		return nil
	}

	cfg := g.config.RA

	if g.opts.IncludeComments {
		buf.WriteString("# Router Advertisement settings\n")
	}

	buf.WriteString("enable-ra\n")

	for _, p := range cfg.Params {
		parts := []string{p.Interface}
		if p.MTU > 0 {
			parts = append(parts, fmt.Sprintf("mtu:%d", p.MTU))
		}
		if p.HighPriority {
			parts = append(parts, "high")
		}
		if p.LowPriority {
			parts = append(parts, "low")
		}
		if p.Interval != "" {
			parts = append(parts, p.Interval)
		}
		if p.Lifetime > 0 {
			parts = append(parts, fmt.Sprintf("%d", p.Lifetime))
		}
		fmt.Fprintf(buf, "ra-param=%s\n", strings.Join(parts, ","))
	}

	for _, rdnss := range cfg.RDNSS {
		if rdnss.Lifetime > 0 {
			fmt.Fprintf(buf, "dhcp-option=option6:dns-server,[%s],%d\n",
				rdnss.Address, rdnss.Lifetime)
		}
	}

	buf.WriteString("\n")
	return nil
}

func (g *Generator) generateCustom(buf *bytes.Buffer) error {
	if len(g.config.CustomOptions) == 0 {
		return nil
	}

	if g.opts.IncludeComments {
		buf.WriteString("# Custom options\n")
	}

	for _, opt := range g.config.CustomOptions {
		buf.WriteString(opt)
		buf.WriteString("\n")
	}

	buf.WriteString("\n")
	return nil
}

// escapeQuotes escapes double quotes in strings.
func escapeQuotes(s string) string {
	return strings.ReplaceAll(s, `"`, `\"`)
}
